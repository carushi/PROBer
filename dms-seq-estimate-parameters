#!/usr/bin/env python

import os
import sys
import argparse

import utils
from utils import MyFormatter, MyParser, runProg

#Parse options and arguments

parser = MyParser(formatter_class = MyFormatter, usage = "{} [options] reference_name sample_name channel {{--bam input.bam | --sam input.sam | --reads mate1_read_file(s) [mate2_read_file(s)]}}".format(os.path.basename(utils.expand(sys.argv[0]))), description = "DESCRIPTION: This program helps users to align reads and estimate RNA structure parameters.", epilog = "L:OUTPUTS:\n"
                  "  sample_name.gamma\n"
                  "    Estimated gamma parameters for each transcript. The first line contains the total number of transcripts. "
                       "Then each line describes estimated parameters for a different transcript. "
                       "Within each line, the first field gives the transcript name, the second field provides the number of estimated gamma parameters, "
                       "which is equal to transcript length - primer length. In the end, estimated gamma values at each position were given (from 5' end to 3' end).\n\n"                  
                  "  sample_name_minus.expr\n"
                  "    Isoform level expression estimates for the control data ('-' channel). The first line contains column names separated by a tab character:\n"
                  "    \n"
                  "    transcript_id length effective_length expected_count TPM FPKM\n"
                  "    \n"
                  "    transcript_id gives the transcript's name. length is the transcript length. effective_length represents the number of positions that can generate a fragment. "
                       "It is equal to length - primer_length + 1. expected_count is the sum of posterior probabilities of reads coming from this transcript. TPM is transcript per million. "
                       "FPKM is fragment per kilobase per millon reads.\n\n"
                  "    In the rest lines of the file, each line describes a transcript according to the defined columns.\n\n"
                  "  sample_name_minus.theta\n"
                  "    Estimated probability of generating a fragment (before size selection step) from each transcript in the '-' channel. The first line gives the total number of transcripts, M. "
                       "Then M + 1 values follows in the second line, giving the probability of each transcript. "
                       "Please note that the first value represents the probability of generating a read from background noise.\n\n"
                  "  sample_name_minus.transcripts.bam\n"
                  "    Only generated when '--output-bam' option is set.\n\n"
                  "    It is a BAM-formatted file that contains all '-' channel read alignments in transcript coordinates. "
                       "For each alignable BAM line, The MAPQ field is set to min(100, floor(-10 * log10(1.0 - w) + 0.5)), where w is the posterior probability of that alignment being the true "
                       "mapping of a read."
                       "In addition, a new tag ZW:f:value is added, where the value is a single precision floating number representing the posterior probability. "
                       "All filtered alignment lines has a ZF:A:! tag to identify that it is filtered. "
                       "Because this file contains all alignment lines produced by the aligner, it can also be used as a replacement of the aligner generated BAM/SAM file.\n\n"
                  "  sample_name.beta\n"
                  "    Estimated beta parameters for each transcript. The first line contains the total number of transcripts. "
                       "Then each line describes estimated parameters for a different transcript. "
                       "Within each line, the first field gives the transcript name, the second field provides the number of estimated beta parameters, "
                       "which is equal to transcript length - primer length. In the end, estimated beta values at each position were given (from 5' end to 3' end).\n\n"
                  "  sample_name_plus.expr, sample_name_plus.theta, sample_name_plus.transcripts.bam\n"
                  "    Same format as sample_name_minus.* files, but generated for the experimental data ('+' channel)\n\n"
                  "  sample_name.rate\n"
                  "    Estimated 'c' rates for each transcript. The first line gives the number of transcripts and the second line gives estimated 'c' rate for each transcript. "
                       "Some transcripts will have their 'c' rate as nan or -nan because that some estimated beta values from these transcripts are 1. "
                       "This phenomenon might be due to insufficient data for those transcripts and our use of ML estimates. "
                       "We may design some MAP estimates to remedy this problem in the future.\n\n" 
                  "  sample_name.freq\n"
                  "    Estimated theta values for each transcript as described in Sharon's paper. "
                       "The format is same as 'sample_name.beta' except that if a transcript's c is 0, no estimated theta values will be shown.\n\n"
                  "  sample_name.stat\n"
                  "    Folder contains learned parameters from data. sample_name.stat/sample_name_minus.read_model and sample_name.stat/sample_name_plus.read_model can be used for simulaiton.\n\n"
                  "  sample_name.temp\n"
                  "    Temp folder contains intermediate files.\n\n")
                  
parser.add_argument("ref_name", help = "The name of the reference used. Users should have run 'dms-seq-prepare-reference' with this name before running this program.", type = utils.expand, metavar = "reference_name")
parser.add_argument("sample_name", help = "The output name of this run. All outputs use this name as their prefixes.", type = utils.expand, metavar = "sample_name")
parser.add_argument("channel", help = "Which channel the data come from. Choose from 'plus' or 'minus'.", choices = ['plus', 'minus'], metavar = "channel")

group = parser.add_argument_group(title = "Input", description = "Input alignments or reads, options are mutually exclusive. If input are alignments, all alignments of a same read should group together and each paired-end alignment's two mates should be adjacent.")

group.add_argument("--bam", help = "Input is a BAM file containing alignment results, '-' stands for standard input.", type = utils.expand, metavar = "input.bam")
group.add_argument("--sam", help = "Input is a SAM file containing alignment results, '-' stands for standard input.", type = utils.expand, metavar = "input.sam")
group.add_argument("--reads", help = "L:Input are read files.\nmate1_read_file(s), a comma-separated list of files containing single-end reads or first mates of paired-end reads\n"
                                     "mate2_read_file(s), present only if '--paired-end' is enabled, a comma-separated list of files containing second mates of paired-end reads\n"
                                     "By default, these files should be in FASTQ format. If '--no-quality-scores' is specified, multi-FASTA format files are expected instead.",
                   nargs = '+', action = utils.nargs_range(1, 2), type = utils.expandAll, metavar = "mate_read_file(s)")

group = parser.add_argument_group(title = "Basic options")

group.add_argument("--no-quality-scores", help = "Input reads do not contain quality scores.", action = "store_true", dest = "no_qual")
group.add_argument("--paired-end", help = "Input reads are paired-end reads.", action = "store_true", dest = "paired_end")
group.add_argument("-p", "--number-of-threads", help = "Number of threads this program can use.", type = int, default = 1, dest = "num_threads", metavar = "<int>")
group.add_argument("--output-bam", help = "Output transcript BAM file.", action = "store_true")

group = parser.add_argument_group(title = "Structure-seq related", description = "Set necessary parameters for generating a config file.")
group.add_argument("--primer-length", help = "Random primer length.", type = int, default = 6, metavar = "<int>")
group.add_argument("--size-selection-min", help = "The minimum fragment length that can pass the size selection step.", type = int, required = True, metavar = "<int>")
group.add_argument("--size-selection-max", help = "The maximum fragment length that can pass the size selection step.", type = int, required = True, metavar = "<int>")
group.add_argument("--gamma-init", help = "Intial value for all gammas.", type = float, default = 0.01, metavar = "<float>")
group.add_argument("--beta-init", help = "Initial value for all betas.", type = float, default = 0.01, metavar = "<float>")

group.add_argument("--read-length", help = "Read length before trimming adaptors.", type = int, metavar = "<int>")



group = parser.add_argument_group(title = "Alignment options", description = "User can choose from Bowtie, Bowtie2, and Hobbes2. All reads with more than 200 alignments will be filtered by this script.")
group.add_argument("--bowtie", help = "Use bowtie aligner to align reads, with Bowtie parameters \"--norc -p number_of_threads -n 2 -e 99999999 -l 25 -a -m 200 -S\"."
                   " If \"--paired-end\" is set, additionaly enable Bowtie parameters \"-I 1 -X 1000 --chunkmbs 1024\".", action = "store_true", default = True)
group.add_argument("--bowtie-path", help = "The path to Bowtie executables.", type = utils.expand, metavar = "<path>")
group.add_argument("--bowtie2", help = "Use bowtie2 aligner to align reads, indel alignments enabled, with Bowtie2 parameters \"--norc -p number_of_threads -k 201\"."
                   " If \"--paired-end\" is set, additionaly enable Bowtie2 parameters \"-I 1 -X 1000 --no-mixed --no-discordant\".", action = "store_true")
group.add_argument("--bowtie2-path", help = "The path to Bowtie2 executables.", type = utils.expand, metavar = "<path>")
group.add_argument("--hobbes2", help = "Use hobbes2 aligner to align reads, with Hobbes2 parameters \"--norc -p number_threads -k 201\"."
                   " If \"--paired-end\" is set, use Hobbes2 parameters \"--norc -p number_threads -a --pe --min 1 --max 1000\" instead.", action = "store_true")
group.add_argument("--hobbes2-path", help = "The path to Hobbes2 executables.", type = utils.expand, metavar = "<path>")
group.add_argument("--hobbes2-hamming", help = "Use hamming distance for Hobbes2.", action = "store_true")
group.add_argument("--hobbes2-indel", help = "Use indel distance for Hobbes2.", action = "store_true")
group.add_argument("--hobbes2-v", help = "Hobbes2's distance threshold.", type = int, metavar = "<int>")

parser.add_argument("-q", "--quiet", help = "Suppress the output of logging information.", action = "store_true")

args = parser.parse_args()

value = (1 if args.sam != None else 0) + (1 if args.bam != None else 0) + (1 if args.reads != None else 0)

if value == 0:
    parser.error("There must be at least one input option (--bam, --sam, and --reads) enabled")
elif value > 1:
    parser.error("Input options (--bam, --sam, and --reads) are mutually exclusive")

#Set executable directory

mydir = os.path.dirname(utils.expand(sys.argv[0]))
os.environ["PATH"] = mydir + os.pathsep + os.getenv("PATH", ".")
os.environ["PYTHONPATH"] = mydir + os.pathsep + os.getenv("PYTHONPATH", ".")

#Run programs

#utils.demo = True
       
dir_ = os.path.dirname(args.sample_name)
if dir_ != "":
    dir_ += os.sep
base_ = os.path.basename(args.sample_name)
temp_dir = dir_ + base_ + ".temp" 
imdName = temp_dir + os.sep + base_
stat_dir = dir_ + base_ + ".stat"
statName = stat_dir + os.sep + base_

if not os.path.exists(temp_dir):
    os.makedirs(temp_dir)

if not os.path.exists(stat_dir):
    os.makedirs(stat_dir)

model_type = None
if args.paired_end:
    if args.no_qual:
        model_type = 2
    else:
        model_type = 3
else:
    if args.no_qual:
        model_type = 0
    else:
        model_type = 1


# Parse alignments        
command = []

if args.bam != None or args.sam != None:
    command.extend(["dms-seq-parse-alignments", args.ref_name, imdName, statName, args.channel, str(args.num_threads)])
    if args.bam != None:
        command.extend(["b", args.bam])
    else:
        command.extend(["s", args.sam])
    command.extend(["-m", "200"])
    if args.read_length != None and args.size_selection_min < args.read_length:
        command2.extend(["--shorter-than", str(args.size_selection_min)])        
    if args.quiet:
        command.append("-q")
    runProg(command)
else:
    if args.bowtie2 and args.hobbes2:
        parser.error("--bowtie2 and --hobbes2 are mutually exclusive")
    if args.bowtie2 or args.hobbes2:
        args.bowtie = False

    if args.bowtie:
        command.extend(["{}bowtie".format(args.bowtie_path + os.sep if args.bowtie_path != None else ""), "--norc", "-p", str(args.num_threads)])
        command.extend("-n 2 -e 99999999 -l 25 -a -m 200 -S".split())
        if not args.paired_end:
            command.extend([args.ref_name, args.reads[0]])
        else:
            command.extend("-I 1 -X 1000 --chunkmbs 1024".split())
            command.extend([args.ref_name, "-1", args.reads[0], "-2", args.reads[1]])
    elif args.bowtie2:
        command.extend(["{}bowtie2".format(args.bowtie2_path + os.sep if args.bowtie2_path != None else ""), "--norc", "-p", str(args.num_threads), "-k", "201"])
        if not args.paired_end:
            command.extend(["-x", args.ref_name, "-U", args.reads[0]])
        else:
            command.extend("-I 1 -X 1000 --no-mixed --no-discordant".split())
            command.extend(["-x", args.ref_name, "-1", args.reads[0], "-2", args.reads[1]])
    else:
        if not args.hobbes2_hamming and not args.hobbes2_indel:
            parser.error("One of --hobbes2-hamming and --hobbes2indel must be set")
        elif args.hobbes2_hamming and args.hobbes2_inde:
            parser.error("--hobbes2-hamming and --hobbes2-indel are mutually exclusive")
        if args.hobbes2_v == None:
            parser.error("--hobbes2-v <int> must be set")

        command.extend(["{}hobbes".format(args.hobbes2_path + os.sep if args.hobbes2_path != None else ""), "--norc", "-p", str(args.num_threads)])
        command.extend(["--hamming" if args.hobbes2_hamming else "--indel", "-v", str(args.hobbes2_v)])
        command.extend(["--sref", "{}.idx.fa".format(args.ref_name), "-i", "{}.hix".format(args.ref_name)])
        
        if not args.paired_end:
            command.extend(["-k", "201", "-q", args.reads[0]])
        else:
            command.extend("-a --pe --min 1 --max 1000".split())
            command.extend(["--seqfq1", args.reads[0], "--seqfq2", args.reads[1]])
    command2 = ["dms-seq-parse-alignments", args.ref_name, imdName, statName, args.channel, str(args.num_threads), "s", "-", "-m", "200"]
    if args.read_length != None and args.size_selection_min < args.read_length:
        command2.extend(["--shorter-than", str(args.size_selection_min)])
    if args.quiet:
        command2.append("-q")
    runProg(command, command2)

# Generate config file
fh = open("{}_{}.config".format(imdName, args.channel), 'w')
fh.write("{0}\n{1}\n{2}\n{3}\n{4}\n".format(args.primer_length, args.size_selection_min, args.size_selection_max, args.gamma_init, args.beta_init))
fh.close()

# Run EM    
command = ["dms-seq-run-em", args.ref_name, str(model_type), args.sample_name, imdName, statName, args.channel, str(args.num_threads)]
if args.read_length != None:
    command.extend(["--read-length", str(args.read_length)])
if args.output_bam:
    command.append("--output-bam")
if args.quiet:
    command.append("-q")
runProg(command)
