#!/usr/bin/env python

import os
import sys
import argparse
import glob

import utils
from utils import MyFormatter, MyParser, runProg

#Parse options and arguments

parser = MyParser(formatter_class = MyFormatter, usage = "{} [options] reference_name sample_name channel {{--bam input.bam | --sam input.sam | --reads mate1_read_file(s) [mate2_read_file(s)]}}".format(os.path.basename(sys.argv[0])), description = "DESCRIPTION: This program helps users to align reads and estimate RNA structure parameters.", epilog = "L:OUTPUTS:\n"
                  "  sample_name.gamma\n"
                  "    Estimated gamma parameters for each transcript. The first line contains the total number of transcripts. "
                       "Then each line describes estimated parameters for a different transcript. "
                       "Within each line, the first field gives the transcript name, the second field provides the number of estimated gamma parameters, "
                       "which is equal to transcript length - primer length. In the end, estimated gamma values at each position were given (from 5' end to 3' end).\n\n"                  
                  "  sample_name_minus.expr\n"
                  "    Isoform level expression estimates for the control data ('-' channel). The first line contains column names separated by a tab character:\n"
                  "    \n"
                  "    transcript_id length effective_length expected_count TPM FPKM\n"
                  "    \n"
                  "    transcript_id gives the transcript's name. length is the transcript length. effective_length represents the number of positions that can generate a fragment. "
                       "It is equal to length - primer_length + 1. expected_count is the sum of posterior probabilities of reads coming from this transcript. TPM is transcript per million. "
                       "FPKM is fragment per kilobase per millon reads.\n\n"
                  "    In the rest lines of the file, each line describes a transcript according to the defined columns.\n\n"
                  "  sample_name_minus.theta\n"
                  "    Estimated probability of generating a fragment (before size selection step) from each transcript in the '-' channel. The first line gives the total number of transcripts, M. "
                       "Then M + 1 values follows in the second line, giving the probability of each transcript. "
                       "Please note that the first value represents the probability of generating a read from background noise.\n\n"
                  "  sample_name_minus.transcripts.bam\n"
                  "    Only generated when '--output-bam' option is set.\n\n"
                  "    It is a BAM-formatted file that contains all '-' channel read alignments in transcript coordinates. "
                       "For each alignable BAM line, The MAPQ field is set to min(100, floor(-10 * log10(1.0 - w) + 0.5)), where w is the posterior probability of that alignment being the true "
                       "mapping of a read."
                       "In addition, a new tag ZW:f:value is added, where the value is a single precision floating number representing the posterior probability. "
                       "All filtered alignment lines has a ZF:A:! tag to identify that it is filtered. "
                       "Because this file contains all alignment lines produced by the aligner, it can also be used as a replacement of the aligner generated BAM/SAM file.\n\n"
                  "  sample_name.beta\n"
                  "    Estimated beta parameters for each transcript. The first line contains the total number of transcripts. "
                       "Then each line describes estimated parameters for a different transcript. "
                       "Within each line, the first field gives the transcript name, the second field provides the number of estimated beta parameters, "
                       "which is equal to transcript length - primer length. In the end, estimated beta values at each position were given (from 5' end to 3' end).\n\n"
                  "  sample_name_plus.expr, sample_name_plus.theta, sample_name_plus.transcripts.bam\n"
                  "    Same format as sample_name_minus.* files, but generated for the experimental data ('+' channel)\n\n"
                  "  sample_name.rate\n"
                  "    Estimated 'c' rates for each transcript. The first line gives the number of transcripts and the second line gives estimated 'c' rate for each transcript. "
                       "Some transcripts will have their 'c' rate as nan or -nan because that some estimated beta values from these transcripts are 1. "
                       "This phenomenon might be due to insufficient data for those transcripts and our use of ML estimates. "
                       "We may design some MAP estimates to remedy this problem in the future.\n\n" 
                  "  sample_name.freq\n"
                  "    Estimated theta values for each transcript as described in Sharon's paper. "
                       "The format is same as 'sample_name.beta' except that if a transcript's c is 0, no estimated theta values will be shown.\n\n"
                  "  sample_name.stat\n"
                  "    Folder contains learned parameters from data. sample_name.stat/sample_name_minus.read_model and sample_name.stat/sample_name_plus.read_model can be used for simulaiton.\n\n"
                  "  sample_name.temp\n"
                  "    Temp folder contains intermediate files.\n\n")
                  
parser.add_argument("ref_name", help = "The name of the reference used. Users should have run 'dms-seq-prepare-reference' with this name before running this program.", metavar = "reference_name")
parser.add_argument("sample_name", help = "The output name of this run. All outputs use this name as their prefixes.", metavar = "sample_name")
parser.add_argument("channel", help = "Which channel the data come from. Choose from 'plus' or 'minus'.", choices = ['plus', 'minus'], metavar = "channel")

group = parser.add_argument_group(title = "Input", description = "Input alignments or reads, options are mutually exclusive. If input are alignments, all alignments of a same read should group together and each paired-end alignment's two mates should be adjacent.")

group.add_argument("--bam", help = "Input is a BAM file containing alignment results, '-' stands for standard input.", metavar = "input.bam")
group.add_argument("--sam", help = "Input is a SAM file containing alignment results, '-' stands for standard input.", metavar = "input.sam")
group.add_argument("--reads", help = "L:Input are read files.\nmate1_read_file(s), a comma-separated list of files containing single-end reads or first mates of paired-end reads\n"
                                     "mate2_read_file(s), present only if '--paired-end' is enabled, a comma-separated list of files containing second mates of paired-end reads\n"
                                     "By default, these files should be in FASTQ format. If '--no-quality-scores' is specified, multi-FASTA format files are expected instead.",
                   nargs = '+', action = utils.nargs_range(1, 2), metavar = "mate_read_file(s)")

group = parser.add_argument_group(title = "Basic options")

group.add_argument("--no-quality-scores", help = "Input reads do not contain quality scores.", action = "store_true", dest = "no_qual")
group.add_argument("--paired-end", help = "Input reads are paired-end reads.", action = "store_true", dest = "paired_end")
group.add_argument("-p", "--number-of-threads", help = "Number of threads this program can use.", type = int, default = 1, dest = "num_threads", metavar = "<int>")
group.add_argument("--output-bam", help = "Output transcript BAM file.", action = "store_true")

group = parser.add_argument_group(title = "Structure-seq related", description = "Set necessary parameters for generating a config file.")
group.add_argument("--primer-length", help = "Random primer length.", type = int, default = 6, metavar = "<int>")
group.add_argument("--size-selection-min", help = "The minimum fragment length that can pass the size selection step.", type = int, required = True, metavar = "<int>")
group.add_argument("--size-selection-max", help = "The maximum fragment length that can pass the size selection step.", type = int, required = True, metavar = "<int>")
group.add_argument("--gamma-init", help = "Intial value for all gammas.", type = float, default = 0.01, metavar = "<float>")
group.add_argument("--beta-init", help = "Initial value for all betas.", type = float, default = 0.01, metavar = "<float>")

group = parser.add_argument_group(title = "Alignment options", description = "User can choose from Bowtie, Bowtie2, and Hobbes2. All reads with more than 200 alignments will be filtered by this script.")
group.add_argument("--bowtie", help = "Use bowtie aligner to align reads, with Bowtie parameters \"--norc -p number_of_threads -n 2 -e 99999999 -l 25 -a -m 200 -S\"."
                   " If \"--paired-end\" is set, additionaly enable Bowtie parameters \"-I 1 -X 1000 --chunkmbs 1024\".", action = "store_true", default = True)
group.add_argument("--bowtie-path", help = "The path to Bowtie executables.", metavar = "<path>")
group.add_argument("--bowtie2", help = "Use bowtie2 aligner to align reads, indel alignments enabled, with Bowtie2 parameters \"--norc -p number_of_threads -k 201\"."
                   " If \"--paired-end\" is set, additionaly enable Bowtie2 parameters \"-I 1 -X 1000 --no-mixed --no-discordant\".", action = "store_true")
group.add_argument("--bowtie2-path", help = "The path to Bowtie2 executables.", metavar = "<path>")
group.add_argument("--hobbes2", help = "Use hobbes2 aligner to align reads, with Hobbes2 parameters \"--norc -p number_threads -k 201\"."
                   " If \"--paired-end\" is set, use Hobbes2 parameters \"--norc -p number_threads -a --pe --min 1 --max 1000\" instead.", action = "store_true")
group.add_argument("--hobbes2-path", help = "The path to Hobbes2 executables.", metavar = "<path>")
group.add_argument("--hobbes2-hamming", help = "Use hamming distance for Hobbes2.", action = "store_true")
group.add_argument("--hobbes2-indel", help = "Use indel distance for Hobbes2.", action = "store_true")
group.add_argument("--hobbes2-v", help = "Hobbes2's distance threshold.", type = int, metavar = "<int>")

parser.add_argument("-q", "--quiet", help = "Suppress the output of logging information.", action = "store_true")

args = parser.parse_args()

value = (1 if args.sam != None else 0) + (1 if args.bam != None else 0) + (1 if args.reads != None else 0)

if value == 0:
    parser.error("There must be at least one input option (--bam, --sam, and --reads) enabled")
elif value > 1:
    parser.error("Input options (--bam, --sam, and --reads) are mutually exclusive")

#Set executable directory

mydir = os.path.realpath(os.path.dirname(os.path.expanduser(sys.argv[0])))
os.environ["PATH"] = mydir + os.pathsep + os.getenv("PATH", ".")
os.environ["PYTHONPATH"] = mydir + os.pathsep + os.getenv("PYTHONPATH", ".")

#Run programs

#utils.demo = True
       
refName = os.path.expanduser(args.ref_name)

sampleName = os.path.expanduser(args.sample_name)
dir_ = os.path.dirname(sampleName)
if dir_ != "":
    dir_ += os.sep
base_ = os.path.basename(sampleName)
temp_dir = dir_ + base_ + ".temp" 
imdName = temp_dir + os.sep + base_
stat_dir = dir_ + base_ + ".stat"
statName = stat_dir + os.sep + base_

if not os.path.exists(temp_dir):
    os.makedirs(temp_dir)

if not os.path.exists(stat_dir):
    os.makedirs(stat_dir)

model_type = None
if args.paired_end:
    if args.no_qual:
        model_type = 2
    else:
        model_type = 3
else:
    if args.no_qual:
        model_type = 0
    else:
        model_type = 1

        
command = ""

if args.bam != None or args.sam != None:
    command = "dms-seq-parse-alignments {0} {1} {2} {3} {4}".format(refName, imdName, statName, args.channel, args.num_threads)
    if args.bam != None:
        command += " b {}".format(args.bam)
    else:
        command += " s {}".format(args.sam)
    command += " -m 200"
    if args.quiet:
        command += " -q"
    runProg(command)
else:
    if args.bowtie2 and args.hobbes2:
        parser.error("--bowtie2 and --hobbes2 are mutually exclusive")
    if args.bowtie2 or args.hobbes2:
        args.bowtie = False

    if args.bowtie:
        command = (args.bowtie_path + os.sep if args.bowtie_path != None else "") + "bowtie --norc -p {} -n 2 -e 99999999 -l 25 -a -m 200 -S".format(args.num_threads)
        if not args.paired_end:
            command += " {refName} {mate1}".format(refName = refName, mate1 = args.reads[0])
        else:
            command += " -I 1 -X 1000 --chunkmbs 1024 {refName} -1 {mate1} -2 {mate2}".format(refName = refName, mate1 = args.reads[0], mate2 = args.reads[1])       
    elif args.bowtie2:
        command = (args.bowtie2_path + os.sep if args.bowtie2_path != None else "") + "bowtie2 --norc -p {} -k 201".format(args.num_threads)
        if not args.paired_end:
            command += " -x {refName} -U {mate1}".format(refName = refName, mate1 = args.reads[0])
        else:
            command += " -I 1 -X 1000 --no-mixed --no-discordant -x {refName} -1 {mate1} -2 {mate2}".format(refName = refName, mate1 = args.reads[0], mate2 = args.reads[1])
    else:
        if not args.hobbes2_hamming and not args.hobbes2_indel:
            parser.error("One of --hobbes2-hamming and --hobbes2indel must be set")
        elif args.hobbes2_hamming and args.hobbes2_inde:
            parser.error("--hobbes2-hamming and --hobbes2-indel are mutually exclusive")
        if args.hobbes2_v == None:
            parser.error("--hobbes2-v <int> must be set")

        command = (args.hobbes2_path + os.sep if args.hobbes2_path != None else "") + "hobbes --norc -p {}".format(args.num_threads)
        command += " " + ("--hamming" if args.hobbes2_hamming else "--indel") + " -v {}".format(args.hobbes2_v)
        command += " --sref {refName}.idx.fa -i {refName}.hix".format(refName = refName)
        
        if not args.paired_end:
            command += " -k 201 -q {mate1}".format(mate1 = args.reads[0])
        else:
            command += " -a --pe --min 1 --max 1000 --seqfq1 {mate1} --seqfq2 {mate2}".format(mate1 = args.reads[0], mate2 = args.reads[1])
        
    command += " | dms-seq-parse-alignments {0} {1} {2} {3} {4} s - -m 200".format(refName, imdName, statName, args.channel, args.num_threads)
    runProg(command)

fh = open("{}_{}.config".format(imdName, args.channel), 'w')
fh.write("{0}\n{1}\n{2}\n{3}\n{4}\n".format(args.primer_length, args.size_selection_min, args.size_selection_max, args.gamma_init, args.beta_init))
fh.close()
    
command = "dms-seq-run-em {0} {1} {2} {3} {4} {5} {6}".format(refName, model_type, sampleName, imdName, statName, args.channel, args.num_threads)
if args.output_bam:
    command += " --output-bam"
if args.quiet:
    command += " -q"
runProg(command)

