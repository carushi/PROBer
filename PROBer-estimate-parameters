#!/usr/bin/env python

import os
import sys
import time
import argparse

import utils
from utils import MyFormatter, MyParser, runProg

#Parse options and arguments

program_name = os.path.basename(utils.expand(sys.argv[0]))

parser = MyParser(formatter_class = MyFormatter, usage = "{} [options] reference_name sample_name {{--bam input_minus.bam input_plus.bam | --sam input_minus.sam input_plus.sam | --reads minus_channel_mate1_read_file(s) [minus_channel_mate2_read_file(s)] plus_channel_mate1_read_file(s) [plus_channel_mate2_read_file(s)]}}".format(program_name), description = "DESCRIPTION: This program helps users to align reads and estimate RNA structure parameters.", epilog = "L:OUTPUTS:\n"
                  "  sample_name.expr\n"
                  "    Isoform level expression estimates. The first line contains column names separated by a tab character:\n"
                  "    \n"
                  "    transcript_id length effective_length expected_count_minus expected_count_plus TPM FPKM\n"
                  "    \n"
                  "    transcript_id gives the transcript's name. length is the transcript length. effective_length represents the number of positions that can generate a fragment. "
                       "It is equal to length - primer_length + 1. expected_count_minus is the sum of posterior probabilities of reads coming from this transcript in the (-) channel. "
                       "expected_count_plus is the counts from (+) channel. TPM is transcript per million. FPKM is fragment per kilobase per millon reads.\n\n"
                  "    In the rest lines of the file, each line describes a transcript according to the defined columns.\n\n"
                  "  sample_name.beta\n"
                  "    Estimated beta parameters for each transcript. The first line contains the total number of transcripts. "
                       "Then each line describes estimated parameters for a different transcript. "
                       "Within each line, the first field gives the transcript name, the second field provides the number of estimated beta parameters, "
                       "which is equal to transcript length - primer length. In the end, estimated beta values at each position were given (from 5' end to 3' end).\n\n"
                  "  sample_name.gamma\n"
                  "    Estimated gamma parameters for each transcript. The first line contains the total number of transcripts. "
                       "Then each line describes estimated parameters for a different transcript. "
                       "Within each line, the first field gives the transcript name, the second field provides the number of estimated gamma parameters, "
                       "which is equal to transcript length - primer length. In the end, estimated gamma values at each position were given (from 5' end to 3' end).\n\n"                  
                  "  sample_name_minus.bam\n"
                  "    Only generated when '--output-bam' option is set.\n\n"
                  "    It is a BAM-formatted file that contains annotated '-' channel read alignments in transcript coordinates. "
                       "For each alignable BAM line, The MAPQ field is set to min(100, floor(-10 * log10(1.0 - w) + 0.5)), where w is the posterior probability of that alignment being the true "
                       "mapping of a read. "
                       "In addition, a new tag ZW:f:value is added, where the value is a single precision floating number representing the posterior probability. "
                       "All filtered alignment lines has a ZF:A:! tag to identify that it is filtered. "
                       "Please note that 'ZW' and 'ZF' tags are reserved for PROBer and users need to make sure the aligner output or input BAM/SAM file does not contain these two tags "
                       "unless the input BAM file is produced by PROBer and alignment/filtering criteria are not changed. "
                       "Because this file contains all alignment lines produced by the aligner, it can also be used as a replacement of the aligner generated BAM/SAM file.\n\n"
                  "  sample_name_plus.bam\n"
                  "    Only generated when '--output-bam' option is set.\n\n"
                  "    It is a BAM-formatted file that contains annotated '+' channel read alignments in transcript coordinates. "
                       "The annotation format is exactly the same as the one used in 'sample_name_minus.bam'.\n\n"
                  "  sample_name.stat\n"
                  "    This folder contains learned model parameters from data."
                       "In the folder, 'sample_name_minus.theta' contains the estimated read generating probabilities from '-' channel. "
                       "'sample_name_minus.read_model' contains the estimated sequencing error model from '-' channel. "
                       "'sample_name_plus.theta' contains the estimated read generating probabilities from '+' channel. "
                       "'sample_name_plus.read_model' contains the estimated sequencing error model from '+' channel. "
                       "The files contained in this folder can be used for simulation.\n\n"
                  "  sample_name.temp\n"
                  "    This is a temporary folder contains intermediate files.\n\n")
                  
parser.add_argument("ref_name", help = "The name of the reference used. Users should have run 'dms-seq-prepare-reference' with this name before running this program.", type = utils.expand, metavar = "reference_name")
parser.add_argument("sample_name", help = "The output name of this run. All outputs use this name as their prefixes.", type = utils.expand, metavar = "sample_name")

group = parser.add_argument_group(title = "Input", description = "Input alignments or reads, options are mutually exclusive. If input are alignments, all alignments of a same read should group together and each paired-end alignment's two mates should be adjacent.")

group.add_argument("--bam", help = "Input are BAM files containing alignment results.", nargs = '+', action = utils.nargs_range([2]), type = utils.expandAll,
                   metavar = "input_minus.bam input_plus.bam")
group.add_argument("--sam", help = "Input are SAM files containing alignment results.", nargs = '+', action = utils.nargs_range([2]), type = utils.expandAll,
                   metavar = "input_minus.sam input_plus.bam")
group.add_argument("--reads", help = "L:Input are read files.\nminus_channel_mate1_read_file(s) and plus_channel_mate1_read_file(s) are comma-separated lists of files containing single-end reads or first mates of paired-end reads\n"
                                     "minus_mate2_read_file(s) and plus_mate2_read_file(s), present only if '--paired-end' is enabled, are comma-separated lists of files containing second mates of paired-end reads\n"
                                     "By default, these files should be in FASTQ format. If '--no-quality-scores' is specified, multi-FASTA format files are expected instead.",
                   nargs = '+', action = utils.nargs_range([2, 4]), type = utils.expandAll, metavar = "mate_read_file(s)")

group = parser.add_argument_group(title = "Basic options")

group.add_argument("--no-quality-scores", help = "Input reads do not contain quality scores.", action = "store_true", dest = "no_qual")
group.add_argument("--paired-end", help = "Input reads are paired-end reads.", action = "store_true", dest = "paired_end")
group.add_argument("-p", "--number-of-threads", help = "Number of threads this program can use.", type = int, default = 1, dest = "num_threads", metavar = "<int>")
group.add_argument("--output-bam", help = "Output transcript BAM file.", action = "store_true")

group = parser.add_argument_group(title = "Structure-seq related", description = "Set necessary parameters for generating a config file.")
group.add_argument("--primer-length", help = "Random primer length.", type = int, default = 6, metavar = "<int>")
group.add_argument("--size-selection-min", help = "The minimum fragment length that can pass the size selection step.", type = int, required = True, metavar = "<int>")
group.add_argument("--size-selection-max", help = "The maximum fragment length that can pass the size selection step.", type = int, required = True, metavar = "<int>")
group.add_argument("--gamma-init", help = "Intial value for all gammas.", type = float, default = 0.0001, metavar = "<float>")
group.add_argument("--beta-init", help = "Initial value for all betas.", type = float, default = 0.0001, metavar = "<float>")

group.add_argument("--read-length", help = "Read length before trimming adaptors.", type = int, metavar = "<int>")
group.add_argument("--maximum-likelihood", help = "Use maximum likelihood estimates.", action = "store_true", dest = "ml_est")


group = parser.add_argument_group(title = "Alignment options", description = "User can choose from Bowtie and Bowtie2. All reads with more than 200 alignments will be filtered by this script.")
group.add_argument("--bowtie", help = "Use bowtie aligner to align reads, with Bowtie parameters \"--norc -p number_of_threads -n 2 -e 99999999 -l 25 -a -m 200 -S\"."
                   " If \"--paired-end\" is set, additionaly enable Bowtie parameters \"-I 1 -X 1000 --chunkmbs 1024\".", action = "store_true", default = True)
group.add_argument("--bowtie-path", help = "The path to Bowtie executables.", type = utils.expand, metavar = "<path>")
group.add_argument("--bowtie2", help = "Use bowtie2 aligner to align reads, indel alignments enabled, with Bowtie2 parameters \"--norc -p number_of_threads -k 201\"."
                   " If \"--paired-end\" is set, additionaly enable Bowtie2 parameters \"-I 1 -X 1000 --no-mixed --no-discordant\".", action = "store_true")
group.add_argument("--bowtie2-path", help = "The path to Bowtie2 executables.", type = utils.expand, metavar = "<path>")

parser.add_argument("--time", help = "Output time consumed by each step.", action = "store_true")
parser.add_argument("-q", "--quiet", help = "Suppress the output of logging information.", action = "store_true")

args = parser.parse_args()

value = (1 if args.sam != None else 0) + (1 if args.bam != None else 0) + (1 if args.reads != None else 0)

if value == 0:
    parser.error("There must be at least one input option (--bam, --sam, and --reads) enabled")
elif value > 1:
    parser.error("Input options (--bam, --sam, and --reads) are mutually exclusive")

#Set executable directory

mydir = os.path.dirname(utils.expand(sys.argv[0]))
os.environ["PATH"] = mydir + os.pathsep + os.getenv("PATH", ".")
os.environ["PYTHONPATH"] = mydir + os.pathsep + os.getenv("PYTHONPATH", ".")

#Run programs

#utils.demo = True
       
dir_ = os.path.dirname(args.sample_name)
if dir_ != "":
    dir_ += os.sep
base_ = os.path.basename(args.sample_name)
temp_dir = dir_ + base_ + ".temp" 
imdName = temp_dir + os.sep + base_
stat_dir = dir_ + base_ + ".stat"
statName = stat_dir + os.sep + base_

if not os.path.exists(temp_dir):
    os.makedirs(temp_dir)

if not os.path.exists(stat_dir):
    os.makedirs(stat_dir)

model_type = None
if args.paired_end:
    if args.no_qual:
        model_type = 2
    else:
        model_type = 3
else:
    if args.no_qual:
        model_type = 0
    else:
        model_type = 1

t1 = t2 = t3 = 0.00

if args.time:
    t1 = time.time()

# Parse alignments
command = []
posChannel = 4

if args.bam != None or args.sam != None:
    command.extend(["PROBer-parse-alignments", args.ref_name, imdName, statName, "minus", str(args.num_threads)])
    if args.bam != None:
        command.extend(["b", args.bam[0]])
    else:
        command.extend(["s", args.sam[0]])
    pos = len(command) - 1
    command.extend(["-m", "200"])
    if args.read_length != None and args.size_selection_min < args.read_length:
        command.extend(["--shorter-than", str(args.size_selection_min)])        
    if args.quiet:
        command.append("-q")

    runProg(command)  # Run PROBer-parse-alignments on (-) channel

    command[posChannel] = "plus"
    command[pos] = args.bam[1] if args.bam != None else args.sam[1]
    runProg(command)  # Run PROBer-parse-alignments on (+) channel
     
else:
    if args.bowtie2:
        args.bowtie = False

    if args.bowtie:
        command.extend(["{}bowtie".format(args.bowtie_path + os.sep if args.bowtie_path != None else ""), "--norc", "-p", str(args.num_threads)])
#        command.extend("-n 2 -e 99999999 -l 25 -a -m 200 -S".split())
        command.extend("-v 3 -a -m 200 -S".split())  # For formal release, need to comment this line out
        if not args.paired_end:
            command.extend([args.ref_name, args.reads[0]])
        else:
            command.extend("-I 1 -X 1000 --chunkmbs 1024".split())
            command.extend([args.ref_name, "-1", args.reads[0], "-2", args.reads[1]])
    elif args.bowtie2:
        command.extend(["{}bowtie2".format(args.bowtie2_path + os.sep if args.bowtie2_path != None else ""), "--norc", "-p", str(args.num_threads), "-k", "201"])
        if not args.paired_end:
            command.extend(["-x", args.ref_name, "-U", args.reads[0]])
        else:
            command.extend("-I 1 -X 1000 --no-mixed --no-discordant".split())
            command.extend(["-x", args.ref_name, "-1", args.reads[0], "-2", args.reads[1]])
    else:
        assert False

    command2 = ["PROBer-parse-alignments", args.ref_name, imdName, statName, "minus", str(args.num_threads), "s", "-", "-m", "200"]
    if args.read_length != None and args.size_selection_min < args.read_length:
        command2.extend(["--shorter-than", str(args.size_selection_min)])
    if args.quiet:
        command2.append("-q")
    runProg(command, command2, "{}_minus.err".format(statName))  # Run aligner and then parse for (-) channel data

    pos = len(command) - 1
    if not args.paired_end:
        command[pos] = args.reads[1]
    else:
        command[pos - 2] = args.reads[2]
        command[pos] = args.reads[3]
    command2[posChannel] = "plus"

    runProg(command, command2, "{}_plus.err".format(statName))  # Run aligner and then parse for (+) channel data

if args.time:
    t2 = time.time()

# Generate config file
fh = open("{}.config".format(imdName), 'w')
fh.write("{0}\n{1}\n{2}\n{3}\n{4}\n".format(args.primer_length, args.size_selection_min, args.size_selection_max, args.gamma_init, args.beta_init))
fh.close()

# Run EM    
command = ["PROBer-run-em", args.ref_name, str(model_type), args.sample_name, imdName, statName, str(args.num_threads)]
if args.read_length != None:
    command.extend(["--read-length", str(args.read_length)])
if args.ml_est:
    command.append("--maximum-likelihood")
if args.output_bam:
    command.append("--output-bam")
if args.quiet:
    command.append("-q")
runProg(command)

if args.time:
    t3 = time.time()
    fo = open("{}.time".format(args.sample_name), "w")
    fo.write("Alignment/Parsing: {:.0f}s or {:.2f}m or {:.2f}h\n".format((t2 - t1), (t2 - t1) / 60.0, (t2 - t1) / 3600.0))
    fo.write("EM: {:.0f}s or {:.2f}m or {:.2f}h\n".format((t3 - t2), (t3 - t2) / 60.0, (t3 - t2) / 3600.0))
    fo.close()
